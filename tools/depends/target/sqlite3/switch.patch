--- sqlite3.c
+++ sqlite3.c
@@ -11605,7 +11605,7 @@ SQLITE_PRIVATE void sqlite3HashClear(Hash*);
 # define LONGDOUBLE_TYPE long double
 #endif
 typedef sqlite_int64 i64;          /* 8-byte signed integer */
-typedef sqlite_uint64 u64;         /* 8-byte unsigned integer */
+//typedef sqlite_uint64 sqlite_uint64;         /* 8-byte unsigned integer */
 typedef UINT32_TYPE u32;           /* 4-byte unsigned integer */
 typedef UINT16_TYPE u16;           /* 2-byte unsigned integer */
 typedef INT16_TYPE i16;            /* 2-byte signed integer */
@@ -11613,12 +11613,12 @@ typedef UINT8_TYPE u8;             /* 1-byte unsigned integer */
 typedef INT8_TYPE i8;              /* 1-byte signed integer */
 
 /*
-** SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value
+** SQLITE_MAX_U32 is a sqlite_uint64 constant that is the maximum sqlite_uint64 value
 ** that can be stored in a u32 without loss of data.  The value
 ** is 0x00000000ffffffff.  But because of quirks of some compilers, we
 ** have to specify the value in the less intuitive manner shown:
 */
-#define SQLITE_MAX_U32  ((((u64)1)<<32)-1)
+#define SQLITE_MAX_U32  ((((sqlite_uint64)1)<<32)-1)
 
 /*
 ** The datatype used to store estimates of the number of rows in a
@@ -11627,7 +11627,7 @@ typedef INT8_TYPE i8;              /* 1-byte signed integer */
 ** can be used at compile-time if desired.
 */
 #ifdef SQLITE_64BIT_STATS
- typedef u64 tRowcnt;    /* 64-bit only if requested at compile-time */
+ typedef sqlite_uint64 tRowcnt;    /* 64-bit only if requested at compile-time */
 #else
  typedef u32 tRowcnt;    /* 32-bit is the default */
 #endif
@@ -11678,7 +11678,7 @@ typedef INT16_TYPE LogEst;
 #elif SQLITE_PTRSIZE==4
   typedef u32 uptr;
 #else
-  typedef u64 uptr;
+  typedef sqlite_uint64 uptr;
 #endif
 
 /*
@@ -11771,6 +11771,13 @@ typedef INT16_TYPE LogEst;
 # define SQLITE_MAX_MMAP_SIZE 0
 #endif
 
+#if defined(__SWITCH__)
+# undef SQLITE_MAX_MMAP_SIZE
+# define SQLITE_MAX_MMAP_SIZE 0
+#define SQLITE_OMIT_WAL 1
+#define HAVE_POSIX_FALLOCATE 0
+#endif
+
 /*
 ** Default maximum size of memory used by memory-mapped I/O in the VFS
 */
@@ -12427,7 +12434,7 @@ struct VdbeOp {
 #endif
 #ifdef VDBE_PROFILE
   u32 cnt;                 /* Number of times this instruction was executed */
-  u64 cycles;              /* Total time spent executing this instruction */
+  sqlite_uint64 cycles;              /* Total time spent executing this instruction */
 #endif
 #ifdef SQLITE_VDBE_COVERAGE
   int iSrcLine;            /* Source-code line that generated this opcode */
@@ -13909,7 +13916,7 @@ struct sqlite3 {
   void **aExtension;            /* Array of shared library handles */
   int (*xTrace)(u32,void*,void*,void*);     /* Trace function */
   void *pTraceArg;                          /* Argument to the trace function */
-  void (*xProfile)(void*,const char*,u64);  /* Profiling function */
+  void (*xProfile)(void*,const char*,sqlite_uint64);  /* Profiling function */
   void *pProfileArg;                        /* Argument to profile function */
   void *pCommitArg;                 /* Argument to xCommitCallback() */
   int (*xCommitCallback)(void*);    /* Invoked at every commit. */
@@ -15054,7 +15061,7 @@ struct IdList {
 #ifdef SQLITE_BITMASK_TYPE
   typedef SQLITE_BITMASK_TYPE Bitmask;
 #else
-  typedef u64 Bitmask;
+  typedef sqlite_uint64 Bitmask;
 #endif
 
 /*
@@ -16007,16 +16014,16 @@ SQLITE_PRIVATE char *sqlite3ColumnType(Column*,char*);
 
 SQLITE_PRIVATE int sqlite3MallocInit(void);
 SQLITE_PRIVATE void sqlite3MallocEnd(void);
-SQLITE_PRIVATE void *sqlite3Malloc(u64);
-SQLITE_PRIVATE void *sqlite3MallocZero(u64);
-SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, u64);
-SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, u64);
-SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3*, u64);
+SQLITE_PRIVATE void *sqlite3Malloc(sqlite_uint64);
+SQLITE_PRIVATE void *sqlite3MallocZero(sqlite_uint64);
+SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, sqlite_uint64);
+SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, sqlite_uint64);
+SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3*, sqlite_uint64);
 SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3*,const char*);
-SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*,const char*, u64);
-SQLITE_PRIVATE void *sqlite3Realloc(void*, u64);
-SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);
-SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, u64);
+SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*,const char*, sqlite_uint64);
+SQLITE_PRIVATE void *sqlite3Realloc(void*, sqlite_uint64);
+SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, sqlite_uint64);
+SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, sqlite_uint64);
 SQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*);
 SQLITE_PRIVATE int sqlite3MallocSize(void*);
 SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*);
@@ -16438,7 +16445,7 @@ SQLITE_PRIVATE int sqlite3Atoi(const char*);
 SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);
 SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte);
 SQLITE_PRIVATE u32 sqlite3Utf8Read(const u8**);
-SQLITE_PRIVATE LogEst sqlite3LogEst(u64);
+SQLITE_PRIVATE LogEst sqlite3LogEst(sqlite_uint64);
 SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst,LogEst);
 #ifndef SQLITE_OMIT_VIRTUALTABLE
 SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double);
@@ -16446,7 +16453,7 @@ SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double);
 #if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
     defined(SQLITE_ENABLE_STAT3_OR_STAT4) || \
     defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
-SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst);
+SQLITE_PRIVATE sqlite_uint64 sqlite3LogEstToInt(LogEst);
 #endif
 
 /*
@@ -16454,10 +16461,10 @@ SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst);
 ** be defined locally, but now we use the varint routines in the util.c
 ** file.
 */
-SQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, u64);
-SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *, u64 *);
+SQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, sqlite_uint64);
+SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *, sqlite_uint64 *);
 SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *, u32 *);
-SQLITE_PRIVATE int sqlite3VarintLen(u64 v);
+SQLITE_PRIVATE int sqlite3VarintLen(sqlite_uint64 v);
 
 /*
 ** The common case is for a varint to be a single byte.  They following
@@ -16608,7 +16615,7 @@ SQLITE_PRIVATE int sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_v
 /*
 ** The interface to the LEMON-generated parser
 */
-SQLITE_PRIVATE void *sqlite3ParserAlloc(void*(*)(u64));
+SQLITE_PRIVATE void *sqlite3ParserAlloc(void*(*)(sqlite_uint64));
 SQLITE_PRIVATE void sqlite3ParserFree(void*, void(*)(void*));
 SQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*);
 #ifdef YYTRACKMAXSTACKDEPTH
@@ -17727,7 +17734,7 @@ struct VdbeCursor {
   VdbeCursor *pAltCursor; /* Associated index cursor from which to read */
   int *aAltMap;           /* Mapping from table to index column numbers */
 #ifdef SQLITE_ENABLE_COLUMN_USED_MASK
-  u64 maskUsed;         /* Mask of columns used by this cursor */
+  sqlite_uint64 maskUsed;         /* Mask of columns used by this cursor */
 #endif
 
   /* Cached information about the header for the data record that the
@@ -19446,7 +19453,7 @@ static void strftimeFunc(
   sqlite3_value **argv
 ){
   DateTime x;
-  u64 n;
+  sqlite_uint64 n;
   size_t i,j;
   char *z;
   sqlite3 *db;
@@ -19491,11 +19498,11 @@ static void strftimeFunc(
   }
   testcase( n==sizeof(zBuf)-1 );
   testcase( n==sizeof(zBuf) );
-  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH]+1 );
-  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH] );
+  testcase( n==(sqlite_uint64)db->aLimit[SQLITE_LIMIT_LENGTH]+1 );
+  testcase( n==(sqlite_uint64)db->aLimit[SQLITE_LIMIT_LENGTH] );
   if( n<sizeof(zBuf) ){
     z = zBuf;
-  }else if( n>(u64)db->aLimit[SQLITE_LIMIT_LENGTH] ){
+  }else if( n>(sqlite_uint64)db->aLimit[SQLITE_LIMIT_LENGTH] ){
     sqlite3_result_error_toobig(context);
     return;
   }else{
@@ -21886,9 +21893,9 @@ static SQLITE_WSD struct Mem5Global {
   /*
   ** Performance statistics
   */
-  u64 nAlloc;         /* Total number of calls to malloc */
-  u64 totalAlloc;     /* Total of all malloc calls - includes internal frag */
-  u64 totalExcess;    /* Total internal fragmentation */
+  sqlite_uint64 nAlloc;         /* Total number of calls to malloc */
+  sqlite_uint64 totalAlloc;     /* Total of all malloc calls - includes internal frag */
+  sqlite_uint64 totalExcess;    /* Total internal fragmentation */
   u32 currentOut;     /* Current checkout, including internal fragmentation */
   u32 currentCount;   /* Current number of distinct checkouts */
   u32 maxOut;         /* Maximum instantaneous currentOut */
@@ -24084,7 +24091,7 @@ static int mallocWithAlarm(int n, void **pp){
 ** Allocate memory.  This routine is like sqlite3_malloc() except that it
 ** assumes the memory subsystem has already been initialized.
 */
-SQLITE_PRIVATE void *sqlite3Malloc(u64 n){
+SQLITE_PRIVATE void *sqlite3Malloc(sqlite_uint64 n){
   void *p;
   if( n==0 || n>=0x7fffff00 ){
     /* A memory allocation of a number of bytes which is near the maximum
@@ -24324,7 +24331,7 @@ SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
 /*
 ** Change the size of an existing memory allocation
 */
-SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){
+SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, sqlite_uint64 nBytes){
   int nOld, nNew, nDiff;
   void *pNew;
   assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );
@@ -24394,7 +24401,7 @@ SQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){
 /*
 ** Allocate and zero memory.
 */ 
-SQLITE_PRIVATE void *sqlite3MallocZero(u64 n){
+SQLITE_PRIVATE void *sqlite3MallocZero(sqlite_uint64 n){
   void *p = sqlite3Malloc(n);
   if( p ){
     memset(p, 0, (size_t)n);
@@ -24406,7 +24413,7 @@ SQLITE_PRIVATE void *sqlite3MallocZero(u64 n){
 ** Allocate and zero memory.  If the allocation fails, make
 ** the mallocFailed flag in the connection pointer.
 */
-SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, u64 n){
+SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, sqlite_uint64 n){
   void *p;
   testcase( db==0 );
   p = sqlite3DbMallocRaw(db, n);
@@ -24418,7 +24425,7 @@ SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, u64 n){
 /* Finish the work of sqlite3DbMallocRawNN for the unusual and
 ** slower case when the allocation cannot be fulfilled using lookaside.
 */
-static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){
+static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, sqlite_uint64 n){
   void *p;
   assert( db!=0 );
   p = sqlite3Malloc(n);
@@ -24450,14 +24457,14 @@ static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){
 ** The sqlite3MallocRawNN() variant guarantees that the "db" parameter is
 ** not a NULL pointer.
 */
-SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){
+SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, sqlite_uint64 n){
   void *p;
   if( db ) return sqlite3DbMallocRawNN(db, n);
   p = sqlite3Malloc(n);
   sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
   return p;
 }
-SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){
+SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, sqlite_uint64 n){
 #ifndef SQLITE_OMIT_LOOKASIDE
   LookasideSlot *pBuf;
   assert( db!=0 );
@@ -24493,20 +24500,20 @@ SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){
 }
 
 /* Forward declaration */
-static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n);
+static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, sqlite_uint64 n);
 
 /*
 ** Resize the block of memory pointed to by p to n bytes. If the
 ** resize fails, set the mallocFailed flag in the connection object.
 */
-SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){
+SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, sqlite_uint64 n){
   assert( db!=0 );
   if( p==0 ) return sqlite3DbMallocRawNN(db, n);
   assert( sqlite3_mutex_held(db->mutex) );
   if( isLookaside(db,p) && n<=db->lookaside.sz ) return p;
   return dbReallocFinish(db, p, n);
 }
-static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){
+static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, sqlite_uint64 n){
   void *pNew = 0;
   assert( db!=0 );
   assert( p!=0 );
@@ -24536,7 +24543,7 @@ static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){
 ** Attempt to reallocate p.  If the reallocation fails, then free p
 ** and set the mallocFailed flag in the database connection.
 */
-SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){
+SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, sqlite_uint64 n){
   void *pNew;
   pNew = sqlite3DbRealloc(db, p, n);
   if( !pNew ){
@@ -24566,7 +24573,7 @@ SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z){
   }
   return zNew;
 }
-SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){
+SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, sqlite_uint64 n){
   char *zNew;
   assert( db!=0 );
   if( z==0 ){
@@ -25037,7 +25044,7 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
           }
           if( v<0 ){
             if( v==SMALLEST_INT64 ){
-              longvalue = ((u64)1)<<63;
+              longvalue = ((sqlite_uint64)1)<<63;
             }else{
               longvalue = -v;
             }
@@ -25050,9 +25057,9 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
           }
         }else{
           if( bArgList ){
-            longvalue = (u64)getIntArg(pArgList);
+            longvalue = (sqlite_uint64)getIntArg(pArgList);
           }else if( flag_longlong ){
-            longvalue = va_arg(ap,u64);
+            longvalue = va_arg(ap,sqlite_uint64);
           }else if( flag_long ){
             longvalue = va_arg(ap,unsigned long int);
           }else{
@@ -27773,7 +27780,7 @@ static int compare2pow63(const char *zNum, int incr){
 */
 SQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){
   int incr;
-  u64 u = 0;
+  sqlite_uint64 u = 0;
   int neg = 0; /* assume positive */
   int i;
   int c = 0;
@@ -27862,7 +27869,7 @@ SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char *z, i64 *pOut){
   if( z[0]=='0'
    && (z[1]=='x' || z[1]=='X')
   ){
-    u64 u = 0;
+    sqlite_uint64 u = 0;
     int i, k;
     for(i=2; z[i]=='0'; i++){}
     for(k=i; sqlite3Isxdigit(z[k]); k++){
@@ -27980,10 +27987,10 @@ SQLITE_PRIVATE int sqlite3Atoi(const char *z){
 ** bit clear.  Except, if we get to the 9th byte, it stores the full
 ** 8 bits and is the last byte.
 */
-static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){
+static int SQLITE_NOINLINE putVarint64(unsigned char *p, sqlite_uint64 v){
   int i, j, n;
   u8 buf[10];
-  if( v & (((u64)0xff000000)<<32) ){
+  if( v & (((sqlite_uint64)0xff000000)<<32) ){
     p[8] = (u8)v;
     v >>= 8;
     for(i=7; i>=0; i--){
@@ -28004,7 +28011,7 @@ static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){
   }
   return n;
 }
-SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v){
+SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, sqlite_uint64 v){
   if( v<=0x7f ){
     p[0] = v&0x7f;
     return 1;
@@ -28034,7 +28041,7 @@ SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v){
 ** Read a 64-bit variable-length integer from memory starting at p[0].
 ** Return the number of bytes read.  The value is stored in *v.
 */
-SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
+SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, sqlite_uint64 *v){
   u32 a,b,s;
 
   a = *p;
@@ -28114,7 +28121,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
     b = b<<7;
     a |= b;
     s = s>>18;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 5;
   }
 
@@ -28135,7 +28142,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
     a = a<<7;
     a |= b;
     s = s>>18;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 6;
   }
 
@@ -28150,7 +28157,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
     b = b<<7;
     a |= b;
     s = s>>11;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 7;
   }
 
@@ -28168,7 +28175,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
     a = a<<7;
     a |= b;
     s = s>>4;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 8;
   }
 
@@ -28189,7 +28196,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
   b = b>>3;
   s |= b;
 
-  *v = ((u64)s)<<32 | a;
+  *v = ((sqlite_uint64)s)<<32 | a;
 
   return 9;
 }
@@ -28260,7 +28267,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
   */
 #if 1
   {
-    u64 v64;
+    sqlite_uint64 v64;
     u8 n;
 
     p -= 2;
@@ -28312,7 +28319,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
   ** slow) general-purpose sqlite3GetVarint() routine to extract the
   ** value. */
   {
-    u64 v64;
+    sqlite_uint64 v64;
     u8 n;
 
     p -= 4;
@@ -28328,7 +28335,7 @@ SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
 ** Return the number of bytes that will be needed to store the given
 ** 64-bit integer.
 */
-SQLITE_PRIVATE int sqlite3VarintLen(u64 v){
+SQLITE_PRIVATE int sqlite3VarintLen(sqlite_uint64 v){
   int i;
   for(i=1; (v >>= 7)!=0; i++){ assert( i<10 ); }
   return i;
@@ -28615,7 +28622,7 @@ SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst a, LogEst b){
 ** Convert an integer into a LogEst.  In other words, compute an
 ** approximation for 10*log2(x).
 */
-SQLITE_PRIVATE LogEst sqlite3LogEst(u64 x){
+SQLITE_PRIVATE LogEst sqlite3LogEst(sqlite_uint64 x){
   static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };
   LogEst y = 40;
   if( x<8 ){
@@ -28634,11 +28641,11 @@ SQLITE_PRIVATE LogEst sqlite3LogEst(u64 x){
 ** In other words, compute an approximation for 10*log2(x).
 */
 SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double x){
-  u64 a;
+  sqlite_uint64 a;
   LogEst e;
   assert( sizeof(x)==8 && sizeof(a)==8 );
   if( x<=1 ) return 0;
-  if( x<=2000000000 ) return sqlite3LogEst((u64)x);
+  if( x<=2000000000 ) return sqlite3LogEst((sqlite_uint64)x);
   memcpy(&a, &x, 8);
   e = (a>>52) - 1022;
   return e*10;
@@ -28654,15 +28661,15 @@ SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double x){
 ** Note that this routine is only used when one or more of various
 ** non-standard compile-time options is enabled.
 */
-SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst x){
-  u64 n;
+SQLITE_PRIVATE sqlite_uint64 sqlite3LogEstToInt(LogEst x){
+  sqlite_uint64 n;
   n = x%10;
   x /= 10;
   if( n>=5 ) n -= 2;
   else if( n>=1 ) n -= 1;
 #if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
     defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
-  if( x>60 ) return (u64)LARGEST_INT64;
+  if( x>60 ) return (sqlite_uint64)LARGEST_INT64;
 #else
   /* If only SQLITE_ENABLE_STAT3_OR_STAT4 is on, then the largest input
   ** possible to this routine is 310, resulting in a maximum x of 31 */
@@ -34784,7 +34791,7 @@ static int unixGetTempname(int nBuf, char *zBuf){
   zDir = unixTempFileDir();
   if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;
   do{
-    u64 r;
+    sqlite_uint64 r;
     sqlite3_randomness(sizeof(r), &r);
     assert( nBuf>2 );
     zBuf[nBuf-2] = 0;
@@ -59234,7 +59241,7 @@ static void btreeParseCellPtrNoPayload(
 #ifndef SQLITE_DEBUG
   UNUSED_PARAMETER(pPage);
 #endif
-  pInfo->nSize = 4 + getVarint(&pCell[4], (u64*)&pInfo->nKey);
+  pInfo->nSize = 4 + getVarint(&pCell[4], (sqlite_uint64*)&pInfo->nKey);
   pInfo->nPayload = 0;
   pInfo->nLocal = 0;
   pInfo->pPayload = 0;
@@ -59247,7 +59254,7 @@ static void btreeParseCellPtr(
 ){
   u8 *pIter;              /* For scanning through pCell */
   u32 nPayload;           /* Number of bytes of cell payload */
-  u64 iKey;               /* Extracted Key value */
+  sqlite_uint64 iKey;               /* Extracted Key value */
 
   assert( sqlite3_mutex_held(pPage->pBt->mutex) );
   assert( pPage->leaf==0 || pPage->leaf==1 );
@@ -59273,7 +59280,7 @@ static void btreeParseCellPtr(
 
   /* The next block of code is equivalent to:
   **
-  **     pIter += getVarint(pIter, (u64*)&pInfo->nKey);
+  **     pIter += getVarint(pIter, (sqlite_uint64*)&pInfo->nKey);
   **
   ** The code is inlined to avoid a function call.
   */
@@ -60412,7 +60419,7 @@ SQLITE_PRIVATE int sqlite3BtreeOpen(
     ** when compiling on a different architecture.
     */
     assert( sizeof(i64)==8 );
-    assert( sizeof(u64)==8 );
+    assert( sizeof(sqlite_uint64)==8 );
     assert( sizeof(u32)==4 );
     assert( sizeof(u16)==2 );
     assert( sizeof(Pgno)==4 );
@@ -63285,7 +63292,7 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
             if( pCell>=pPage->aDataEnd ) return SQLITE_CORRUPT_BKPT;
           }
         }
-        getVarint(pCell, (u64*)&nCellKey);
+        getVarint(pCell, (sqlite_uint64*)&nCellKey);
         if( nCellKey<intKey ){
           lwr = idx+1;
           if( lwr>upr ){ c = -1; break; }
@@ -64239,7 +64246,7 @@ static int fillInCell(
     nSrc = pX->nData;
     assert( pPage->intKeyLeaf ); /* fillInCell() only called for leaves */
     nHeader += putVarint32(&pCell[nHeader], nPayload);
-    nHeader += putVarint(&pCell[nHeader], *(u64*)&pX->nKey);
+    nHeader += putVarint(&pCell[nHeader], *(sqlite_uint64*)&pX->nKey);
   }else{
     assert( pX->nData==0 );
     assert( pX->nZero==0 );
@@ -73503,7 +73510,7 @@ SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen){
     /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */
 #   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)
     i64 i = pMem->u.i;
-    u64 u;
+    sqlite_uint64 u;
     if( i<0 ){
       u = ~i;
     }else{
@@ -73611,9 +73618,9 @@ SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type){
 ** so we trust him.
 */
 #ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
-static u64 floatSwap(u64 in){
+static sqlite_uint64 floatSwap(sqlite_uint64 in){
   union {
-    u64 r;
+    sqlite_uint64 r;
     u32 i[2];
   } u;
   u32 t;
@@ -73647,7 +73654,7 @@ SQLITE_PRIVATE u32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){
 
   /* Integer and Real */
   if( serial_type<=7 && serial_type>0 ){
-    u64 v;
+    sqlite_uint64 v;
     u32 i;
     if( serial_type==7 ){
       assert( sizeof(v)==sizeof(pMem->u.r) );
@@ -73701,7 +73708,7 @@ static u32 SQLITE_NOINLINE serialGet(
   u32 serial_type,              /* Serial type to deserialize */
   Mem *pMem                     /* Memory cell to write value into */
 ){
-  u64 x = FOUR_BYTE_UINT(buf);
+  sqlite_uint64 x = FOUR_BYTE_UINT(buf);
   u32 y = FOUR_BYTE_UINT(buf+4);
   x = (x<<32) + y;
   if( serial_type==6 ){
@@ -73719,9 +73726,9 @@ static u32 SQLITE_NOINLINE serialGet(
     ** defined that 64-bit floating point values really are mixed
     ** endian.
     */
-    static const u64 t1 = ((u64)0x3ff00000)<<32;
+    static const sqlite_uint64 t1 = ((sqlite_uint64)0x3ff00000)<<32;
     static const double r1 = 1.0;
-    u64 t2 = t1;
+    sqlite_uint64 t2 = t1;
     swapMixedEndianFloat(t2);
     assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );
 #endif
@@ -74241,7 +74248,7 @@ static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){
       return FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);
     }
     case 6: {
-      u64 x = FOUR_BYTE_UINT(aKey);
+      sqlite_uint64 x = FOUR_BYTE_UINT(aKey);
       testcase( aKey[0]&0x80 );
       x = (x<<32) | FOUR_BYTE_UINT(aKey+4);
       return (i64)*(i64*)&x;
@@ -74476,7 +74483,7 @@ static int vdbeRecordCompareInt(
   int serial_type = ((const u8*)pKey1)[1];
   int res;
   u32 y;
-  u64 x;
+  sqlite_uint64 x;
   i64 v = pPKey2->aMem[0].u.i;
   i64 lhs;
 
@@ -74683,7 +74690,7 @@ SQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){
   */
   assert( sqlite3BtreeCursorIsValid(pCur) );
   nCellKey = sqlite3BtreePayloadSize(pCur);
-  assert( (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey );
+  assert( (nCellKey & SQLITE_MAX_U32)==(sqlite_uint64)nCellKey );
 
   /* Read in the complete content of the index entry */
   sqlite3VdbeMemInit(&m, db, 0);
@@ -75405,10 +75412,10 @@ SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetZeroBlob(pCtx->pOut, n);
 }
-SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){
+SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *pCtx, sqlite_uint64 n){
   Mem *pOut = pCtx->pOut;
   assert( sqlite3_mutex_held(pOut->db->mutex) );
-  if( n>(u64)pOut->db->aLimit[SQLITE_LIMIT_LENGTH] ){
+  if( n>(sqlite_uint64)pOut->db->aLimit[SQLITE_LIMIT_LENGTH] ){
     return SQLITE_TOOBIG;
   }
   sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);
@@ -76402,7 +76409,7 @@ SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint6
   int rc;
   Vdbe *p = (Vdbe *)pStmt;
   sqlite3_mutex_enter(p->db->mutex);
-  if( n>(u64)p->db->aLimit[SQLITE_LIMIT_LENGTH] ){
+  if( n>(sqlite_uint64)p->db->aLimit[SQLITE_LIMIT_LENGTH] ){
     rc = SQLITE_TOOBIG;
   }else{
     assert( (n & 0x7FFFFFFF)==n );
@@ -77731,7 +77738,7 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
   int *aPermute = 0;         /* Permutation of columns for OP_Compare */
   i64 lastRowid = db->lastRowid;  /* Saved value of the last insert ROWID */
 #ifdef VDBE_PROFILE
-  u64 start;                 /* CPU clock count at start of opcode */
+  sqlite_uint64 start;                 /* CPU clock count at start of opcode */
 #endif
   /*** INSERT STACK UNION HERE ***/
 
@@ -78885,7 +78892,7 @@ case OP_BitOr:                  /* same as TK_BITOR, in1, in2, out3 */
 case OP_ShiftLeft:              /* same as TK_LSHIFT, in1, in2, out3 */
 case OP_ShiftRight: {           /* same as TK_RSHIFT, in1, in2, out3 */
   i64 iA;
-  u64 uA;
+  sqlite_uint64 uA;
   i64 iB;
   u8 op;
 
@@ -78922,7 +78929,7 @@ case OP_ShiftRight: {           /* same as TK_RSHIFT, in1, in2, out3 */
       }else{
         uA >>= iB;
         /* Sign-extend on a right shift of a negative number */
-        if( iA<0 ) uA |= ((((u64)0xffffffff)<<32)|0xffffffff) << (64-iB);
+        if( iA<0 ) uA |= ((((sqlite_uint64)0xffffffff)<<32)|0xffffffff) << (64-iB);
       }
       memcpy(&iA, &uA, sizeof(iA));
     }
@@ -79543,7 +79550,7 @@ case OP_Column: {
   const u8 *zHdr;    /* Next unparsed byte of the header */
   const u8 *zEndHdr; /* Pointer to first byte after the header */
   u32 offset;        /* Offset into the data */
-  u64 offset64;      /* 64-bit offset */
+  sqlite_uint64 offset64;      /* 64-bit offset */
   u32 avail;         /* Number of bytes of available data */
   u32 t;             /* A type code from the record header */
   Mem *pReg;         /* PseudoTable input register */
@@ -79816,7 +79823,7 @@ case OP_Affinity: {
 case OP_MakeRecord: {
   u8 *zNewRecord;        /* A buffer to hold the data for the new record */
   Mem *pRec;             /* The new record */
-  u64 nData;             /* Number of bytes of data space */
+  sqlite_uint64 nData;             /* Number of bytes of data space */
   int nHdr;              /* Number of bytes of header space */
   i64 nByte;             /* Data space required for this record */
   i64 nZero;             /* Number of zero bytes at the end of the record */
@@ -80759,7 +80766,7 @@ case OP_ColumnsUsed: {
   VdbeCursor *pC;
   pC = p->apCsr[pOp->p1];
   assert( pC->eCurType==CURTYPE_BTREE );
-  pC->maskUsed = *(u64*)pOp->p4.pI64;
+  pC->maskUsed = *(sqlite_uint64*)pOp->p4.pI64;
   break;
 }
 #endif
@@ -80925,7 +80932,7 @@ case OP_SeekGT: {       /* jump, in3 */
         if( (oc & 0x0001)==(OP_SeekLT & 0x0001) ) oc++;
       }
     } 
-    rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)iKey, 0, &res);
+    rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (sqlite_uint64)iKey, 0, &res);
     pC->movetoTarget = iKey;  /* Used by OP_Delete */
     if( rc!=SQLITE_OK ){
       goto abort_due_to_error;
@@ -81211,7 +81218,7 @@ case OP_SeekRowid: {        /* jump, in3 */
   VdbeCursor *pC;
   BtCursor *pCrsr;
   int res;
-  u64 iKey;
+  sqlite_uint64 iKey;
 
   pIn3 = &aMem[pOp->p3];
   if( (pIn3->flags & MEM_Int)==0 ){
@@ -81326,7 +81333,7 @@ case OP_NewRowid: {           /* out2 */
     ** Others complain about 0x7ffffffffffffffffLL.  The following macro seems
     ** to provide the constant while making all compilers happy.
     */
-#   define MAX_ROWID  (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
+#   define MAX_ROWID  (i64)( (((sqlite_uint64)0x7fffffff)<<32) | (sqlite_uint64)0xffffffff )
 #endif
 
     if( !pC->useRandomRowid ){
@@ -81388,7 +81395,7 @@ case OP_NewRowid: {           /* out2 */
       do{
         sqlite3_randomness(sizeof(v), &v);
         v &= (MAX_ROWID>>1); v++;  /* Ensure that v is greater than zero */
-      }while(  ((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)v,
+      }while(  ((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (sqlite_uint64)v,
                                                  0, &res))==SQLITE_OK)
             && (res==0)
             && (++cnt<100));
@@ -84027,7 +84034,7 @@ default: {          /* This is really OP_Noop and OP_Explain */
 
 #ifdef VDBE_PROFILE
     {
-      u64 endTime = sqlite3Hwtime();
+      sqlite_uint64 endTime = sqlite3Hwtime();
       if( endTime>start ) pOrigOp->cycles += endTime - start;
       pOrigOp->cnt++;
     }
@@ -85207,7 +85214,7 @@ static int vdbePmaReadBlob(
 ** Read a varint from the stream of data accessed by p. Set *pnOut to
 ** the value read.
 */
-static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){
+static int vdbePmaReadVarint(PmaReader *p, sqlite_uint64 *pnOut){
   int iBuf;
 
   if( p->aMap ){
@@ -85306,7 +85313,7 @@ static int vdbePmaReaderSeek(
 */
 static int vdbePmaReaderNext(PmaReader *pReadr){
   int rc = SQLITE_OK;             /* Return Code */
-  u64 nRec = 0;                   /* Size of record in bytes */
+  sqlite_uint64 nRec = 0;                   /* Size of record in bytes */
 
 
   if( pReadr->iReadOff>=pReadr->iEof ){
@@ -85367,7 +85374,7 @@ static int vdbePmaReaderInit(
 
   rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);
   if( rc==SQLITE_OK ){
-    u64 nByte = 0;                 /* Size of PMA in bytes */
+    sqlite_uint64 nByte = 0;                 /* Size of PMA in bytes */
     rc = vdbePmaReadVarint(pReadr, &nByte);
     pReadr->iEof = pReadr->iReadOff + nByte;
     *pnByte += nByte;
@@ -86159,7 +86166,7 @@ static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof){
 ** Write value iVal encoded as a varint to the PMA. Return 
 ** SQLITE_OK if successful, or an SQLite error code if an error occurs.
 */
-static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){
+static void vdbePmaWriteVarint(PmaWriter *p, sqlite_uint64 iVal){
   int nByte; 
   u8 aByte[10];
   nByte = sqlite3PutVarint(aByte, iVal);
@@ -95517,11 +95524,11 @@ static void statGet(
       return;
     }
 
-    sqlite3_snprintf(24, zRet, "%llu", (u64)p->nRow);
+    sqlite3_snprintf(24, zRet, "%llu", (sqlite_uint64)p->nRow);
     z = zRet + sqlite3Strlen30(zRet);
     for(i=0; i<p->nKeyCol; i++){
-      u64 nDistinct = p->current.anDLt[i] + 1;
-      u64 iVal = (p->nRow + nDistinct - 1) / nDistinct;
+      sqlite_uint64 nDistinct = p->current.anDLt[i] + 1;
+      sqlite_uint64 iVal = (p->nRow + nDistinct - 1) / nDistinct;
       sqlite3_snprintf(24, z, " %llu", iVal);
       z += sqlite3Strlen30(z);
       assert( p->current.anEq[i] );
@@ -95569,7 +95576,7 @@ static void statGet(
         int i;
         char *z = zRet;
         for(i=0; i<p->nCol; i++){
-          sqlite3_snprintf(24, z, "%llu ", (u64)aCnt[i]);
+          sqlite3_snprintf(24, z, "%llu ", (sqlite_uint64)aCnt[i]);
           z += sqlite3Strlen30(z);
         }
         assert( z[0]=='\0' && z>zRet );
@@ -103571,7 +103578,7 @@ static void substrFunc(
       p2 = len-p1;
       if( p2<0 ) p2 = 0;
     }
-    sqlite3_result_blob64(context, (char*)&z[p1], (u64)p2, SQLITE_TRANSIENT);
+    sqlite3_result_blob64(context, (char*)&z[p1], (sqlite_uint64)p2, SQLITE_TRANSIENT);
   }
 }
 
@@ -104236,7 +104243,7 @@ static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
     }
     case SQLITE_TEXT: {
       int i,j;
-      u64 n;
+      sqlite_uint64 n;
       const unsigned char *zArg = sqlite3_value_text(argv[0]);
       char *z;
 
@@ -109837,7 +109844,7 @@ static int sqlite3LoadExtension(
   const char *zEntry;
   char *zAltEntry = 0;
   void **aHandle;
-  u64 nMsg = 300 + sqlite3Strlen30(zFile);
+  sqlite_uint64 nMsg = 300 + sqlite3Strlen30(zFile);
   int ii;
   int rc;
 
@@ -110074,7 +110081,7 @@ SQLITE_API int sqlite3_auto_extension(
       if( wsdAutoext.aExt[i]==xInit ) break;
     }
     if( i==wsdAutoext.nExt ){
-      u64 nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);
+      sqlite_uint64 nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);
       void (**aNew)(void);
       aNew = sqlite3_realloc64(wsdAutoext.aExt, nByte);
       if( aNew==0 ){
@@ -115243,7 +115250,7 @@ SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(
   int i;
   Expr *p;
   struct ExprList_item *a;
-  u64 szAll = 0;
+  sqlite_uint64 szAll = 0;
 
   assert( pSelect!=0 );
   assert( (pSelect->selFlags & SF_Resolved)!=0 );
@@ -115379,8 +115386,8 @@ static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
       VdbeComment((v, "LIMIT counter"));
       if( n==0 ){
         sqlite3VdbeGoto(v, iBreak);
-      }else if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){
-        p->nSelectRow = sqlite3LogEst((u64)n);
+      }else if( n>=0 && p->nSelectRow>sqlite3LogEst((sqlite_uint64)n) ){
+        p->nSelectRow = sqlite3LogEst((sqlite_uint64)n);
         p->selFlags |= SF_FixedLimit;
       }
     }else{
@@ -115824,9 +115831,9 @@ static int multiSelect(
       p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
       if( pPrior->pLimit
        && sqlite3ExprIsInteger(pPrior->pLimit, &nLimit)
-       && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) 
+       && nLimit>0 && p->nSelectRow > sqlite3LogEst((sqlite_uint64)nLimit) 
       ){
-        p->nSelectRow = sqlite3LogEst((u64)nLimit);
+        p->nSelectRow = sqlite3LogEst((sqlite_uint64)nLimit);
       }
       if( addr ){
         sqlite3VdbeJumpHere(v, addr);
@@ -131313,14 +131320,14 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
         VdbeComment((v, "%s", pIx->zName));
 #ifdef SQLITE_ENABLE_COLUMN_USED_MASK
         {
-          u64 colUsed = 0;
+          sqlite_uint64 colUsed = 0;
           int ii, jj;
           for(ii=0; ii<pIx->nColumn; ii++){
             jj = pIx->aiColumn[ii];
             if( jj<0 ) continue;
             if( jj>63 ) jj = 63;
             if( (pTabItem->colUsed & MASKBIT(jj))==0 ) continue;
-            colUsed |= ((u64)1)<<(ii<63 ? ii : 63);
+            colUsed |= ((sqlite_uint64)1)<<(ii<63 ? ii : 63);
           }
           sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, iIndexCur, 0, 0,
                                 (u8*)&colUsed, P4_INT64);
@@ -131604,7 +131611,7 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
 ** Alternative datatype for the argument to the malloc() routine passed
 ** into sqlite3ParserAlloc().  The default is size_t.
 */
-#define YYMALLOCARGTYPE  u64
+#define YYMALLOCARGTYPE  sqlite_uint64
 
 /*
 ** An instance of this structure holds information about the
@@ -136793,7 +136800,7 @@ SQLITE_API int sqlite3_initialize(void){
 #ifndef SQLITE_OMIT_FLOATING_POINT
   /* This section of code's only "output" is via assert() statements. */
   if ( rc==SQLITE_OK ){
-    u64 x = (((u64)1)<<63)-1;
+    sqlite_uint64 x = (((sqlite_uint64)1)<<63)-1;
     double y;
     assert(sizeof(x)==8);
     assert(sizeof(x)==sizeof(y));
@@ -139070,7 +139077,7 @@ SQLITE_PRIVATE int sqlite3ParseUri(
     int eState;                   /* Parser state when parsing URI */
     int iIn;                      /* Input character index */
     int iOut = 0;                 /* Output character index */
-    u64 nByte = nUri+2;           /* Bytes of space to allocate */
+    sqlite_uint64 nByte = nUri+2;           /* Bytes of space to allocate */
 
     /* Make sure the SQLITE_OPEN_URI flag is set to indicate to the VFS xOpen 
     ** method that there may be extra parameters following the file-name.  */
@@ -141613,7 +141620,7 @@ SQLITE_PRIVATE int sqlite3Fts3Never(int b);
 typedef unsigned char u8;         /* 1-byte (or larger) unsigned integer */
 typedef short int i16;            /* 2-byte (or larger) signed integer */
 typedef unsigned int u32;         /* 4-byte unsigned integer */
-typedef sqlite3_uint64 u64;       /* 8-byte unsigned integer */
+typedef sqlite3_uint64 sqlite_uint64;       /* 8-byte unsigned integer */
 typedef sqlite3_int64 i64;        /* 8-byte signed integer */
 
 /*
@@ -142138,7 +142145,7 @@ SQLITE_PRIVATE int sqlite3Fts3PutVarint(char *p, sqlite_int64 v){
 SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *p, sqlite_int64 *v){
   const char *pStart = p;
   u32 a;
-  u64 b;
+  sqlite_uint64 b;
   int shift;
 
   GETVARINT_INIT(a, p, 0,  0x00,     0x80, *v, 1);
@@ -142148,7 +142155,7 @@ SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *p, sqlite_int64 *v){
   b = (a & 0x0FFFFFFF );
 
   for(shift=28; shift<=63; shift+=7){
-    u64 c = *p++;
+    sqlite_uint64 c = *p++;
     b += (c&0x7F) << shift;
     if( (c & 0x80)==0 ) break;
   }
@@ -156887,7 +156894,7 @@ static int fts3DoAutoincrmerge(
 ** Return a 64-bit checksum for the FTS index entry specified by the
 ** arguments to this function.
 */
-static u64 fts3ChecksumEntry(
+static sqlite_uint64 fts3ChecksumEntry(
   const char *zTerm,              /* Pointer to buffer containing term */
   int nTerm,                      /* Size of zTerm in bytes */
   int iLangid,                    /* Language id for current row */
@@ -156897,7 +156904,7 @@ static u64 fts3ChecksumEntry(
   int iPos                        /* Position */
 ){
   int i;
-  u64 ret = (u64)iDocid;
+  sqlite_uint64 ret = (sqlite_uint64)iDocid;
 
   ret += (ret<<3) + iLangid;
   ret += (ret<<3) + iIndex;
@@ -156917,7 +156924,7 @@ static u64 fts3ChecksumEntry(
 ** Otherwise, if an error occurs, *pRc is set to an SQLite error code. The
 ** return value is undefined in this case.
 */
-static u64 fts3ChecksumIndex(
+static sqlite_uint64 fts3ChecksumIndex(
   Fts3Table *p,                   /* FTS3 table handle */
   int iLangid,                    /* Language id to return cksum for */
   int iIndex,                     /* Index to cksum (0..p->nIndex-1) */
@@ -156926,7 +156933,7 @@ static u64 fts3ChecksumIndex(
   Fts3SegFilter filter;
   Fts3MultiSegReader csr;
   int rc;
-  u64 cksum = 0;
+  sqlite_uint64 cksum = 0;
 
   assert( *pRc==SQLITE_OK );
 
@@ -156993,8 +157000,8 @@ static u64 fts3ChecksumIndex(
 */
 static int fts3IntegrityCheck(Fts3Table *p, int *pbOk){
   int rc = SQLITE_OK;             /* Return code */
-  u64 cksum1 = 0;                 /* Checksum based on FTS index contents */
-  u64 cksum2 = 0;                 /* Checksum based on %_content contents */
+  sqlite_uint64 cksum1 = 0;                 /* Checksum based on FTS index contents */
+  sqlite_uint64 cksum2 = 0;                 /* Checksum based on %_content contents */
   sqlite3_stmt *pAllLangid = 0;   /* Statement to return all language-ids */
 
   /* This block calculates the checksum according to the FTS index. */
@@ -157599,8 +157606,8 @@ struct SnippetPhrase {
 struct SnippetFragment {
   int iCol;                       /* Column snippet is extracted from */
   int iPos;                       /* Index of first token in snippet */
-  u64 covered;                    /* Mask of query phrases covered */
-  u64 hlmask;                     /* Mask of snippet terms to highlight */
+  sqlite_uint64 covered;                    /* Mask of query phrases covered */
+  sqlite_uint64 hlmask;                     /* Mask of snippet terms to highlight */
 };
 
 /*
@@ -157934,17 +157941,17 @@ static int fts3SnippetNextCandidate(SnippetIter *pIter){
 */
 static void fts3SnippetDetails(
   SnippetIter *pIter,             /* Snippet iterator */
-  u64 mCovered,                   /* Bitmask of phrases already covered */
+  sqlite_uint64 mCovered,                   /* Bitmask of phrases already covered */
   int *piToken,                   /* OUT: First token of proposed snippet */
   int *piScore,                   /* OUT: "Score" for this snippet */
-  u64 *pmCover,                   /* OUT: Bitmask of phrases covered */
-  u64 *pmHighlight                /* OUT: Bitmask of terms to highlight */
+  sqlite_uint64 *pmCover,                   /* OUT: Bitmask of phrases covered */
+  sqlite_uint64 *pmHighlight                /* OUT: Bitmask of terms to highlight */
 ){
   int iStart = pIter->iCurrent;   /* First token of snippet */
   int iScore = 0;                 /* Score of this snippet */
   int i;                          /* Loop counter */
-  u64 mCover = 0;                 /* Mask of phrases covered by this snippet */
-  u64 mHighlight = 0;             /* Mask of tokens to highlight in snippet */
+  sqlite_uint64 mCover = 0;                 /* Mask of phrases covered by this snippet */
+  sqlite_uint64 mHighlight = 0;             /* Mask of tokens to highlight in snippet */
 
   for(i=0; i<pIter->nPhrase; i++){
     SnippetPhrase *pPhrase = &pIter->aPhrase[i];
@@ -157954,8 +157961,8 @@ static void fts3SnippetDetails(
 
       while( iCsr<(iStart+pIter->nSnippet) ){
         int j;
-        u64 mPhrase = (u64)1 << i;
-        u64 mPos = (u64)1 << (iCsr - iStart);
+        sqlite_uint64 mPhrase = (sqlite_uint64)1 << i;
+        sqlite_uint64 mPos = (sqlite_uint64)1 << (iCsr - iStart);
         assert( iCsr>=iStart );
         if( (mCover|mCovered)&mPhrase ){
           iScore++;
@@ -158031,8 +158038,8 @@ static int fts3BestSnippet(
   int nSnippet,                   /* Desired snippet length */
   Fts3Cursor *pCsr,               /* Cursor to create snippet for */
   int iCol,                       /* Index of column to create snippet from */
-  u64 mCovered,                   /* Mask of phrases already covered */
-  u64 *pmSeen,                    /* IN/OUT: Mask of phrases seen */
+  sqlite_uint64 mCovered,                   /* Mask of phrases already covered */
+  sqlite_uint64 *pmSeen,                    /* IN/OUT: Mask of phrases seen */
   SnippetFragment *pFragment,     /* OUT: Best snippet found */
   int *piScore                    /* OUT: Score of snippet pFragment */
 ){
@@ -158077,7 +158084,7 @@ static int fts3BestSnippet(
     /* Set the *pmSeen output variable. */
     for(i=0; i<nList; i++){
       if( sIter.aPhrase[i].pHead ){
-        *pmSeen |= (u64)1 << i;
+        *pmSeen |= (sqlite_uint64)1 << i;
       }
     }
 
@@ -158088,8 +158095,8 @@ static int fts3BestSnippet(
     while( !fts3SnippetNextCandidate(&sIter) ){
       int iPos;
       int iScore;
-      u64 mCover;
-      u64 mHighlite;
+      sqlite_uint64 mCover;
+      sqlite_uint64 mHighlite;
       fts3SnippetDetails(&sIter, mCovered, &iPos, &iScore, &mCover,&mHighlite);
       assert( iScore>=0 );
       if( iScore>iBestScore ){
@@ -158172,17 +158179,17 @@ static int fts3SnippetShift(
   const char *zDoc,               /* Document text to extract snippet from */
   int nDoc,                       /* Size of buffer zDoc in bytes */
   int *piPos,                     /* IN/OUT: First token of snippet */
-  u64 *pHlmask                    /* IN/OUT: Mask of tokens to highlight */
+  sqlite_uint64 *pHlmask                    /* IN/OUT: Mask of tokens to highlight */
 ){
-  u64 hlmask = *pHlmask;          /* Local copy of initial highlight-mask */
+  sqlite_uint64 hlmask = *pHlmask;          /* Local copy of initial highlight-mask */
 
   if( hlmask ){
     int nLeft;                    /* Tokens to the left of first highlight */
     int nRight;                   /* Tokens to the right of last highlight */
     int nDesired;                 /* Ideal number of tokens to shift forward */
 
-    for(nLeft=0; !(hlmask & ((u64)1 << nLeft)); nLeft++);
-    for(nRight=0; !(hlmask & ((u64)1 << (nSnippet-1-nRight))); nRight++);
+    for(nLeft=0; !(hlmask & ((sqlite_uint64)1 << nLeft)); nLeft++);
+    for(nRight=0; !(hlmask & ((sqlite_uint64)1 << (nSnippet-1-nRight))); nRight++);
     nDesired = (nLeft-nRight)/2;
 
     /* Ideally, the start of the snippet should be pushed forward in the
@@ -158248,7 +158255,7 @@ static int fts3SnippetText(
   int iEnd = 0;                   /* Byte offset of end of current token */
   int isShiftDone = 0;            /* True after snippet is shifted */
   int iPos = pFragment->iPos;     /* First token of snippet */
-  u64 hlmask = pFragment->hlmask; /* Highlight-mask for snippet */
+  sqlite_uint64 hlmask = pFragment->hlmask; /* Highlight-mask for snippet */
   int iCol = pFragment->iCol+1;   /* Query column to extract text from */
   sqlite3_tokenizer_module *pMod; /* Tokenizer module methods object */
   sqlite3_tokenizer_cursor *pC;   /* Tokenizer cursor open on zDoc/nDoc */
@@ -158329,7 +158336,7 @@ static int fts3SnippetText(
     }
 
     /* Set isHighlight to true if this term should be highlighted. */
-    isHighlight = (hlmask & ((u64)1 << (iCurrent-iPos)))!=0;
+    isHighlight = (hlmask & ((sqlite_uint64)1 << (iCurrent-iPos)))!=0;
 
     if( iCurrent>iPos ) rc = fts3StringAppend(pOut, &zDoc[iEnd], iBegin-iEnd);
     if( rc==SQLITE_OK && isHighlight ) rc = fts3StringAppend(pOut, zOpen, -1);
@@ -158950,8 +158957,8 @@ SQLITE_PRIVATE void sqlite3Fts3Snippet(
   for(nSnippet=1; 1; nSnippet++){
 
     int iSnip;                    /* Loop counter 0..nSnippet-1 */
-    u64 mCovered = 0;             /* Bitmask of phrases covered by snippet */
-    u64 mSeen = 0;                /* Bitmask of phrases seen by BestSnippet() */
+    sqlite_uint64 mCovered = 0;             /* Bitmask of phrases covered by snippet */
+    sqlite_uint64 mSeen = 0;                /* Bitmask of phrases seen by BestSnippet() */
 
     if( nToken>=0 ){
       nFToken = (nToken+nSnippet-1) / nSnippet;
@@ -170039,7 +170046,7 @@ static int statDecodePage(Btree *pBt, StatPage *p){
         int nLocal;               /* Bytes of payload stored locally */
         iOff += getVarint32(&aData[iOff], nPayload);
         if( p->flags==0x0D ){
-          u64 dummy;
+          sqlite_uint64 dummy;
           iOff += sqlite3GetVarint(&aData[iOff], &dummy);
         }
         if( nPayload>(u32)p->nMxPayload ) p->nMxPayload = nPayload;
@@ -170663,7 +170670,7 @@ static int sessionVarintGet(u8 *aBuf, int *piVal){
 ** the value read.
 */
 static sqlite3_int64 sessionGetI64(u8 *aRec){
-  u64 x = SESSION_UINT32(aRec);
+  sqlite_uint64 x = SESSION_UINT32(aRec);
   u32 y = SESSION_UINT32(aRec+4);
   x = (x<<32) + y;
   return (sqlite3_int64)x;
@@ -170720,12 +170727,12 @@ static int sessionSerializeValue(
           /* TODO: SQLite does something special to deal with mixed-endian
           ** floating point values (e.g. ARM7). This code probably should
           ** too.  */
-          u64 i;
+          sqlite_uint64 i;
           if( eType==SQLITE_INTEGER ){
-            i = (u64)sqlite3_value_int64(pValue);
+            i = (sqlite_uint64)sqlite3_value_int64(pValue);
           }else{
             double r;
-            assert( sizeof(double)==8 && sizeof(u64)==8 );
+            assert( sizeof(double)==8 && sizeof(sqlite_uint64)==8 );
             r = sqlite3_value_double(pValue);
             memcpy(&i, &r, 8);
           }
@@ -175107,7 +175114,7 @@ static const char jsonIsSpace[] = {
 #ifndef SQLITE_AMALGAMATION
   /* Unsigned integer types.  These are already defined in the sqliteInt.h,
   ** but the definitions need to be repeated for separate compilation. */
-  typedef sqlite3_uint64 u64;
+  typedef sqlite3_uint64 sqlite_uint64;
   typedef unsigned int u32;
   typedef unsigned char u8;
 #endif
@@ -175124,8 +175131,8 @@ typedef struct JsonParse JsonParse;
 struct JsonString {
   sqlite3_context *pCtx;   /* Function context - put error messages here */
   char *zBuf;              /* Append JSON content here */
-  u64 nAlloc;              /* Bytes of storage available in zBuf[] */
-  u64 nUsed;               /* Bytes of zBuf[] currently used */
+  sqlite_uint64 nAlloc;              /* Bytes of storage available in zBuf[] */
+  sqlite_uint64 nUsed;               /* Bytes of zBuf[] currently used */
   u8 bStatic;              /* True if zBuf is static space */
   u8 bErr;                 /* True if an error has been encountered */
   char zSpace[100];        /* Initial static space */
@@ -175231,7 +175238,7 @@ static void jsonOom(JsonString *p){
 ** Return zero on success.  Return non-zero on an OOM error
 */
 static int jsonGrow(JsonString *p, u32 N){
-  u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;
+  sqlite_uint64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;
   char *zNew;
   if( p->bStatic ){
     if( p->bErr ) return 1;
@@ -177856,7 +177863,7 @@ typedef unsigned int   u32;
 typedef unsigned short u16;
 typedef short i16;
 typedef sqlite3_int64 i64;
-typedef sqlite3_uint64 u64;
+typedef sqlite3_uint64 sqlite_uint64;
 
 #define ArraySize(x) ((int)(sizeof(x) / sizeof(x[0])))
 
@@ -178192,7 +178199,7 @@ static int sqlite3Fts5IndexClose(Fts5Index *p);
 /*
 ** Return a simple checksum value based on the arguments.
 */
-static u64 sqlite3Fts5IndexEntryCksum(
+static sqlite_uint64 sqlite3Fts5IndexEntryCksum(
   i64 iRowid, 
   int iCol, 
   int iPos, 
@@ -178293,7 +178300,7 @@ static int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8*, int);
 /*
 ** Functions called by the storage module as part of integrity-check.
 */
-static int sqlite3Fts5IndexIntegrityCheck(Fts5Index*, u64 cksum);
+static int sqlite3Fts5IndexIntegrityCheck(Fts5Index*, sqlite_uint64 cksum);
 
 /* 
 ** Called during virtual module initialization to register UDF 
@@ -178325,8 +178332,8 @@ static int sqlite3Fts5IndexLoadConfig(Fts5Index *p);
 */
 static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v);
 static int sqlite3Fts5GetVarintLen(u32 iVal);
-static u8 sqlite3Fts5GetVarint(const unsigned char*, u64*);
-static int sqlite3Fts5PutVarint(unsigned char *p, u64 v);
+static u8 sqlite3Fts5GetVarint(const unsigned char*, sqlite_uint64*);
+static int sqlite3Fts5PutVarint(unsigned char *p, sqlite_uint64 v);
 
 #define fts5GetVarint32(a,b) sqlite3Fts5GetVarint32(a,(u32*)&b)
 #define fts5GetVarint    sqlite3Fts5GetVarint
@@ -178680,7 +178687,7 @@ static int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic);
 ** Alternative datatype for the argument to the malloc() routine passed
 ** into sqlite3ParserAlloc().  The default is size_t.
 */
-#define fts5YYMALLOCARGTYPE  u64
+#define fts5YYMALLOCARGTYPE  sqlite_uint64
 
 /**************** End of %include directives **********************************/
 /* These constants specify the various numeric values for terminal symbols
@@ -181820,7 +181827,7 @@ typedef struct Fts5ExprTerm Fts5ExprTerm;
 /*
 ** Functions generated by lemon from fts5parse.y.
 */
-static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(u64));
+static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(sqlite_uint64));
 static void sqlite3Fts5ParserFree(void*, void (*freeProc)(void*));
 static void sqlite3Fts5Parser(void*, int, Fts5Token, Fts5Parse*);
 #ifndef NDEBUG
@@ -181998,7 +182005,7 @@ static int fts5ExprGetToken(
   return tok;
 }
 
-static void *fts5ParseAlloc(u64 t){ return sqlite3_malloc((int)t); }
+static void *fts5ParseAlloc(sqlite_uint64 t){ return sqlite3_malloc((int)t); }
 static void fts5ParseFree(void *p){ sqlite3_free(p); }
 
 static int sqlite3Fts5ExprNew(
@@ -185314,7 +185321,7 @@ struct Fts5StructureLevel {
 };
 struct Fts5Structure {
   int nRef;                       /* Object reference count */
-  u64 nWriteCounter;              /* Total leaves written to level 0 */
+  sqlite_uint64 nWriteCounter;              /* Total leaves written to level 0 */
   int nSegment;                   /* Total segments in this structure */
   int nLevel;                     /* Number of levels in this index */
   Fts5StructureLevel aLevel[1];   /* Array of nLevel level objects */
@@ -186242,7 +186249,7 @@ static int fts5DlidxLvlNext(Fts5DlidxLvl *pLvl){
     assert( pLvl->bEof==0 );
     pLvl->iOff = 1;
     pLvl->iOff += fts5GetVarint32(&pData->p[1], pLvl->iLeafPgno);
-    pLvl->iOff += fts5GetVarint(&pData->p[pLvl->iOff], (u64*)&pLvl->iRowid);
+    pLvl->iOff += fts5GetVarint(&pData->p[pLvl->iOff], (sqlite_uint64*)&pLvl->iRowid);
     pLvl->iFirstOff = pLvl->iOff;
   }else{
     int iOff;
@@ -186253,7 +186260,7 @@ static int fts5DlidxLvlNext(Fts5DlidxLvl *pLvl){
     if( iOff<pData->nn ){
       i64 iVal;
       pLvl->iLeafPgno += (iOff - pLvl->iOff) + 1;
-      iOff += fts5GetVarint(&pData->p[iOff], (u64*)&iVal);
+      iOff += fts5GetVarint(&pData->p[iOff], (sqlite_uint64*)&iVal);
       pLvl->iRowid += iVal;
       pLvl->iOff = iOff;
     }else{
@@ -186360,7 +186367,7 @@ static int fts5DlidxLvlPrev(Fts5DlidxLvl *pLvl){
       if( (a[iOff-1] & 0x80)==0 ) break;
     }
 
-    fts5GetVarint(&a[iOff], (u64*)&iVal);
+    fts5GetVarint(&a[iOff], (sqlite_uint64*)&iVal);
     pLvl->iRowid -= iVal;
     pLvl->iLeafPgno--;
 
@@ -186586,7 +186593,7 @@ static void fts5SegIterLoadRowid(Fts5Index *p, Fts5SegIter *pIter){
     iOff = 4;
     a = pIter->pLeaf->p;
   }
-  iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
+  iOff += sqlite3Fts5GetVarint(&a[iOff], (sqlite_uint64*)&pIter->iRowid);
   pIter->iLeafOffset = iOff;
 }
 
@@ -186731,7 +186738,7 @@ static void fts5SegIterReverseInitPage(Fts5Index *p, Fts5SegIter *pIter){
       i += nPos;
     }
     if( i>=n ) break;
-    i += fts5GetVarint(&a[i], (u64*)&iDelta);
+    i += fts5GetVarint(&a[i], (sqlite_uint64*)&iDelta);
     pIter->iRowid += iDelta;
 
     /* If necessary, grow the pIter->aRowidOffset[] array. */
@@ -186789,7 +186796,7 @@ static void fts5SegIterReverseNewPage(Fts5Index *p, Fts5SegIter *pIter){
 
       if( pIter->pLeaf ){
         u8 *a = &pIter->pLeaf->p[pIter->iLeafOffset];
-        pIter->iLeafOffset += fts5GetVarint(a, (u64*)&pIter->iRowid);
+        pIter->iLeafOffset += fts5GetVarint(a, (sqlite_uint64*)&pIter->iRowid);
         break;
       }else{
         fts5DataRelease(pNew);
@@ -186839,7 +186846,7 @@ static void fts5SegIterNext_Reverse(
     if( p->pConfig->eDetail!=FTS5_DETAIL_NONE ){
       iOff += pIter->nPos;
     }
-    fts5GetVarint(&a[iOff], (u64*)&iDelta);
+    fts5GetVarint(&a[iOff], (sqlite_uint64*)&iDelta);
     pIter->iRowid -= iDelta;
   }else{
     fts5SegIterReverseNewPage(p, pIter);
@@ -186877,7 +186884,7 @@ static void fts5SegIterNext_None(
   if( iOff<pIter->iEndofDoclist ){
     /* Next entry is on the current page */
     i64 iDelta;
-    iOff += sqlite3Fts5GetVarint(&pIter->pLeaf->p[iOff], (u64*)&iDelta);
+    iOff += sqlite3Fts5GetVarint(&pIter->pLeaf->p[iOff], (sqlite_uint64*)&iDelta);
     pIter->iLeafOffset = iOff;
     pIter->iRowid += iDelta;
   }else if( (pIter->flags & FTS5_SEGITER_ONETERM)==0 ){
@@ -186900,7 +186907,7 @@ static void fts5SegIterNext_None(
       pIter->pLeaf->szLeaf = nList;
       pIter->iEndofDoclist = nList;
       sqlite3Fts5BufferSet(&p->rc,&pIter->term, (int)strlen(zTerm), (u8*)zTerm);
-      pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);
+      pIter->iLeafOffset = fts5GetVarint(pList, (sqlite_uint64*)&pIter->iRowid);
     }
 
     if( pbNewTerm ) *pbNewTerm = 1;
@@ -186955,7 +186962,7 @@ static void fts5SegIterNext(
         iOff += fts5GetVarint32(&a[iOff], nKeep);
       }
     }else{
-      u64 iDelta;
+      sqlite_uint64 iDelta;
       iOff += sqlite3Fts5GetVarint(&a[iOff], &iDelta);
       pIter->iRowid += iDelta;
       assert_nc( iDelta>0 );
@@ -186981,7 +186988,7 @@ static void fts5SegIterNext(
       pIter->iEndofDoclist = nList+1;
       sqlite3Fts5BufferSet(&p->rc, &pIter->term, (int)strlen(zTerm),
           (u8*)zTerm);
-      pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);
+      pIter->iLeafOffset = fts5GetVarint(pList, (sqlite_uint64*)&pIter->iRowid);
       *pbNewTerm = 1;
     }
   }else{
@@ -186993,7 +187000,7 @@ static void fts5SegIterNext(
       if( pLeaf==0 ) break;
       ASSERT_SZLEAF_OK(pLeaf);
       if( (iOff = fts5LeafFirstRowidOff(pLeaf)) && iOff<pLeaf->szLeaf ){
-        iOff += sqlite3Fts5GetVarint(&pLeaf->p[iOff], (u64*)&pIter->iRowid);
+        iOff += sqlite3Fts5GetVarint(&pLeaf->p[iOff], (sqlite_uint64*)&pIter->iRowid);
         pIter->iLeafOffset = iOff;
 
         if( pLeaf->nn>pLeaf->szLeaf ){
@@ -187126,7 +187133,7 @@ static void fts5SegIterReverse(Fts5Index *p, Fts5SegIter *pIter){
     pIter->pLeaf = pLast;
     pIter->iLeafPgno = pgnoLast;
     iOff = fts5LeafFirstRowidOff(pLast);
-    iOff += fts5GetVarint(&pLast->p[iOff], (u64*)&pIter->iRowid);
+    iOff += fts5GetVarint(&pLast->p[iOff], (sqlite_uint64*)&pIter->iRowid);
     pIter->iLeafOffset = iOff;
 
     if( fts5LeafIsTermless(pLast) ){
@@ -187432,7 +187439,7 @@ static void fts5SegIterHashInit(
     pLeaf->p = (u8*)pList;
     pLeaf->nn = pLeaf->szLeaf = nList;
     pIter->pLeaf = pLeaf;
-    pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (u64*)&pIter->iRowid);
+    pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (sqlite_uint64*)&pIter->iRowid);
     pIter->iEndofDoclist = pLeaf->nn;
 
     if( flags & FTS5INDEX_QUERY_DESC ){
@@ -187632,7 +187639,7 @@ static void fts5SegIterGotoPage(
       if( iOff<4 || iOff>=n ){
         p->rc = FTS5_CORRUPT;
       }else{
-        iOff += fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
+        iOff += fts5GetVarint(&a[iOff], (sqlite_uint64*)&pIter->iRowid);
         pIter->iLeafOffset = iOff;
         fts5SegIterLoadNPos(p, pIter);
       }
@@ -188420,7 +188427,7 @@ static void fts5MultiIterNew2(
     pIter->flags = FTS5_SEGITER_ONETERM;
     if( pData->szLeaf>0 ){
       pIter->pLeaf = pData;
-      pIter->iLeafOffset = fts5GetVarint(pData->p, (u64*)&pIter->iRowid);
+      pIter->iLeafOffset = fts5GetVarint(pData->p, (sqlite_uint64*)&pIter->iRowid);
       pIter->iEndofDoclist = pData->nn;
       pNew->aFirst[1].iFirst = 1;
       if( bDesc ){
@@ -188717,8 +188724,8 @@ static i64 fts5DlidxExtractFirstRowid(Fts5Buffer *pBuf){
   i64 iRowid;
   int iOff;
 
-  iOff = 1 + fts5GetVarint(&pBuf->p[1], (u64*)&iRowid);
-  fts5GetVarint(&pBuf->p[iOff], (u64*)&iRowid);
+  iOff = 1 + fts5GetVarint(&pBuf->p[1], (sqlite_uint64*)&iRowid);
+  fts5GetVarint(&pBuf->p[iOff], (sqlite_uint64*)&iRowid);
   return iRowid;
 }
 
@@ -188965,7 +188972,7 @@ static void fts5WriteAppendPoslistData(
     int nCopy = 0;
     while( nCopy<nReq ){
       i64 dummy;
-      nCopy += fts5GetVarint(&a[nCopy], (u64*)&dummy);
+      nCopy += fts5GetVarint(&a[nCopy], (sqlite_uint64*)&dummy);
     }
     fts5BufferAppendBlob(&p->rc, &pPage->buf, nCopy, a);
     a += nCopy;
@@ -189335,7 +189342,7 @@ static void fts5IndexAutomerge(
 ){
   if( p->rc==SQLITE_OK && p->pConfig->nAutomerge>0 ){
     Fts5Structure *pStruct = *ppStruct;
-    u64 nWrite;                   /* Initial value of write-counter */
+    sqlite_uint64 nWrite;                   /* Initial value of write-counter */
     int nWork;                    /* Number of work-quanta to perform */
     int nRem;                     /* Number of leaf pages left to write */
 
@@ -189462,7 +189469,7 @@ static void fts5FlushOneHash(Fts5Index *p){
         ** loop iterates through the poslists that make up the current 
         ** doclist.  */
         while( p->rc==SQLITE_OK && iOff<nDoclist ){
-          iOff += fts5GetVarint(&pDoclist[iOff], (u64*)&iDelta);
+          iOff += fts5GetVarint(&pDoclist[iOff], (sqlite_uint64*)&iDelta);
           iRowid += iDelta;
           
           if( writer.bFirstRowidInPage ){
@@ -189719,7 +189726,7 @@ static void fts5DoclistIterNext(Fts5DoclistIter *pIter){
   }else{
     i64 iDelta;
 
-    p += fts5GetVarint(p, (u64*)&iDelta);
+    p += fts5GetVarint(p, (sqlite_uint64*)&iDelta);
     pIter->iRowid += iDelta;
 
     /* Read position list size */
@@ -189784,7 +189791,7 @@ static void fts5NextRowid(Fts5Buffer *pBuf, int *piOff, i64 *piRowid){
   if( i>=pBuf->n ){
     *piOff = -1;
   }else{
-    u64 iVal;
+    sqlite_uint64 iVal;
     *piOff = i + sqlite3Fts5GetVarint(&pBuf->p[i], &iVal);
     *piRowid += iVal;
   }
@@ -190422,9 +190429,9 @@ static int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize){
   if( p->rc==SQLITE_OK && pData->nn ){
     int i = 0;
     int iCol;
-    i += fts5GetVarint(&pData->p[i], (u64*)pnRow);
+    i += fts5GetVarint(&pData->p[i], (sqlite_uint64*)pnRow);
     for(iCol=0; i<pData->nn && iCol<nCol; iCol++){
-      i += fts5GetVarint(&pData->p[i], (u64*)&anSize[iCol]);
+      i += fts5GetVarint(&pData->p[i], (sqlite_uint64*)&anSize[iCol]);
     }
   }
 
@@ -190494,7 +190501,7 @@ static int sqlite3Fts5IndexLoadConfig(Fts5Index *p){
 /*
 ** Return a simple checksum value based on the arguments.
 */
-static u64 sqlite3Fts5IndexEntryCksum(
+static sqlite_uint64 sqlite3Fts5IndexEntryCksum(
   i64 iRowid, 
   int iCol, 
   int iPos, 
@@ -190503,7 +190510,7 @@ static u64 sqlite3Fts5IndexEntryCksum(
   int nTerm
 ){
   int i;
-  u64 ret = iRowid;
+  sqlite_uint64 ret = iRowid;
   ret += (ret<<3) + iCol;
   ret += (ret<<3) + iPos;
   if( iIdx>=0 ) ret += (ret<<3) + (FTS5_MAIN_PREFIX + iIdx);
@@ -190526,8 +190533,8 @@ static void fts5TestDlidxReverse(
   int iLeaf                       /* Load doclist-index for this leaf */
 ){
   Fts5DlidxIter *pDlidx = 0;
-  u64 cksum1 = 13;
-  u64 cksum2 = 13;
+  sqlite_uint64 cksum1 = 13;
+  sqlite_uint64 cksum2 = 13;
 
   for(pDlidx=fts5DlidxIterInit(p, 0, iSegid, iLeaf);
       fts5DlidxIterEof(p, pDlidx)==0;
@@ -190562,10 +190569,10 @@ static int fts5QueryCksum(
   const char *z,                  /* Index key to query for */
   int n,                          /* Size of index key in bytes */
   int flags,                      /* Flags for Fts5IndexQuery */
-  u64 *pCksum                     /* IN/OUT: Checksum value */
+  sqlite_uint64 *pCksum                     /* IN/OUT: Checksum value */
 ){
   int eDetail = p->pConfig->eDetail;
-  u64 cksum = *pCksum;
+  sqlite_uint64 cksum = *pCksum;
   Fts5IndexIter *pIter = 0;
   int rc = sqlite3Fts5IndexQuery(p, z, n, flags, 0, &pIter);
 
@@ -190604,21 +190611,21 @@ static void fts5TestTerm(
   Fts5Index *p, 
   Fts5Buffer *pPrev,              /* Previous term */
   const char *z, int n,           /* Possibly new term to test */
-  u64 expected,
-  u64 *pCksum
+  sqlite_uint64 expected,
+  sqlite_uint64 *pCksum
 ){
   int rc = p->rc;
   if( pPrev->n==0 ){
     fts5BufferSet(&rc, pPrev, n, (const u8*)z);
   }else
   if( rc==SQLITE_OK && (pPrev->n!=n || memcmp(pPrev->p, z, n)) ){
-    u64 cksum3 = *pCksum;
+    sqlite_uint64 cksum3 = *pCksum;
     const char *zTerm = (const char*)&pPrev->p[1];  /* term sans prefix-byte */
     int nTerm = pPrev->n-1;            /* Size of zTerm in bytes */
     int iIdx = (pPrev->p[0] - FTS5_MAIN_PREFIX);
     int flags = (iIdx==0 ? 0 : FTS5INDEX_QUERY_PREFIX);
-    u64 ck1 = 0;
-    u64 ck2 = 0;
+    sqlite_uint64 ck1 = 0;
+    sqlite_uint64 ck2 = 0;
 
     /* Check that the results returned for ASC and DESC queries are
     ** the same. If not, call this corruption.  */
@@ -190850,7 +190857,7 @@ static void fts5IndexIntegrityCheckSegment(
           if( iRowidOff>=pLeaf->szLeaf ){
             p->rc = FTS5_CORRUPT;
           }else{
-            fts5GetVarint(&pLeaf->p[iRowidOff], (u64*)&iRowid);
+            fts5GetVarint(&pLeaf->p[iRowidOff], (sqlite_uint64*)&iRowid);
             if( iRowid!=fts5DlidxIterRowid(pDlidx) ) p->rc = FTS5_CORRUPT;
           }
           fts5DataRelease(pLeaf);
@@ -190890,16 +190897,16 @@ static void fts5IndexIntegrityCheckSegment(
 ** error, or some other SQLite error code if another error (e.g. OOM)
 ** occurs.
 */
-static int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, u64 cksum){
+static int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, sqlite_uint64 cksum){
   int eDetail = p->pConfig->eDetail;
-  u64 cksum2 = 0;                 /* Checksum based on contents of indexes */
+  sqlite_uint64 cksum2 = 0;                 /* Checksum based on contents of indexes */
   Fts5Buffer poslist = {0,0,0};   /* Buffer used to hold a poslist */
   Fts5Iter *pIter;                /* Used to iterate through entire index */
   Fts5Structure *pStruct;         /* Index structure */
 
 #ifdef SQLITE_DEBUG
   /* Used by extra internal tests only run if NDEBUG is not defined */
-  u64 cksum3 = 0;                 /* Checksum based on contents of indexes */
+  sqlite_uint64 cksum3 = 0;                 /* Checksum based on contents of indexes */
   Fts5Buffer term = {0,0,0};      /* Buffer used to hold most recent term */
 #endif
   const int flags = FTS5INDEX_QUERY_NOOUTPUT;
@@ -191081,7 +191088,7 @@ static void fts5DecodeAverages(
   const char *zSpace = "";
 
   while( i<nBlob ){
-    u64 iVal;
+    sqlite_uint64 iVal;
     i += sqlite3Fts5GetVarint(&pBlob[i], &iVal);
     sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "%s%d", zSpace, (int)iVal);
     zSpace = " ";
@@ -191118,7 +191125,7 @@ static int fts5DecodeDoclist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){
   int iOff = 0;
 
   if( n>0 ){
-    iOff = sqlite3Fts5GetVarint(a, (u64*)&iDocid);
+    iOff = sqlite3Fts5GetVarint(a, (sqlite_uint64*)&iDocid);
     sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);
   }
   while( iOff<n ){
@@ -191129,7 +191136,7 @@ static int fts5DecodeDoclist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){
     iOff += fts5DecodePoslist(pRc, pBuf, &a[iOff], MIN(n-iOff, nPos));
     if( iOff<n ){
       i64 iDelta;
-      iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&iDelta);
+      iOff += sqlite3Fts5GetVarint(&a[iOff], (sqlite_uint64*)&iDelta);
       iDocid += iDelta;
       sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);
     }
@@ -191161,7 +191168,7 @@ static void fts5DecodeRowidList(
 
   while( i<nData ){
     const char *zApp = "";
-    u64 iVal;
+    sqlite_uint64 iVal;
     i += sqlite3Fts5GetVarint(&pData[i], &iVal);
     iRowid += iVal;
 
@@ -194965,7 +194972,7 @@ struct Fts5IntegrityCtx {
   i64 iRowid;
   int iCol;
   int szCol;
-  u64 cksum;
+  sqlite_uint64 cksum;
   Fts5Termset *pTermset;
   Fts5Config *pConfig;
 };
@@ -196982,7 +196989,7 @@ static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v){
   ** routine.
   */
   {
-    u64 v64;
+    sqlite_uint64 v64;
     u8 n;
     p -= 2;
     n = sqlite3Fts5GetVarint(p, &v64);
@@ -197009,7 +197016,7 @@ static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v){
 ** Read a 64-bit variable-length integer from memory starting at p[0].
 ** Return the number of bytes read.  The value is stored in *v.
 */
-static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
+static u8 sqlite3Fts5GetVarint(const unsigned char *p, sqlite_uint64 *v){
   u32 a,b,s;
 
   a = *p;
@@ -197088,7 +197095,7 @@ static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
     b = b<<7;
     a |= b;
     s = s>>18;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 5;
   }
 
@@ -197109,7 +197116,7 @@ static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
     a = a<<7;
     a |= b;
     s = s>>18;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 6;
   }
 
@@ -197124,7 +197131,7 @@ static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
     b = b<<7;
     a |= b;
     s = s>>11;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 7;
   }
 
@@ -197142,7 +197149,7 @@ static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
     a = a<<7;
     a |= b;
     s = s>>4;
-    *v = ((u64)s)<<32 | a;
+    *v = ((sqlite_uint64)s)<<32 | a;
     return 8;
   }
 
@@ -197163,7 +197170,7 @@ static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
   b = b>>3;
   s |= b;
 
-  *v = ((u64)s)<<32 | a;
+  *v = ((sqlite_uint64)s)<<32 | a;
 
   return 9;
 }
@@ -197203,10 +197210,10 @@ static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
 ** bit clear.  Except, if we get to the 9th byte, it stores the full
 ** 8 bits and is the last byte.
 */
-static int FTS5_NOINLINE fts5PutVarint64(unsigned char *p, u64 v){
+static int FTS5_NOINLINE fts5PutVarint64(unsigned char *p, sqlite_uint64 v){
   int i, j, n;
   u8 buf[10];
-  if( v & (((u64)0xff000000)<<32) ){
+  if( v & (((sqlite_uint64)0xff000000)<<32) ){
     p[8] = (u8)v;
     v >>= 8;
     for(i=7; i>=0; i--){
@@ -197228,7 +197235,7 @@ static int FTS5_NOINLINE fts5PutVarint64(unsigned char *p, u64 v){
   return n;
 }
 
-static int sqlite3Fts5PutVarint(unsigned char *p, u64 v){
+static int sqlite3Fts5PutVarint(unsigned char *p, sqlite_uint64 v){
   if( v<=0x7f ){
     p[0] = v&0x7f;
     return 1;
